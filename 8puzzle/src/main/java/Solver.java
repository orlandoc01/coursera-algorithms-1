import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.MinPQ;
import edu.princeton.cs.algs4.StdOut;
import edu.princeton.cs.algs4.Stack;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Solver {
  private final Stack<Board> winningMoves;
  public Solver(Board initial) {
    if (initial == null) {
      throw new IllegalArgumentException();
    }
    this.winningMoves = new Stack<>();
    solveBoard(initial);
  }
  public boolean isSolvable() { return winningMoves.size() > 0; }
  public int moves() { return isSolvable() ? winningMoves.size() - 1 : -1; }
  public Iterable<Board> solution()  { return isSolvable() ? winningMoves : null; }

  public static void main(String[] args) {

    // create initial board from file
    In in = new In(args[0]);
    int n = in.readInt();
    int[][] blocks = new int[n][n];
    for (int i = 0; i < n; i++)
      for (int j = 0; j < n; j++)
        blocks[i][j] = in.readInt();
    Board initial = new Board(blocks);

    // solve the puzzle
    Solver solver = new Solver(initial);

    // print solution to standard output
    if (!solver.isSolvable())
      StdOut.println("No solution possible");
    else {
      StdOut.println("Minimum number of moves = " + solver.moves());
      for (Board board : solver.solution())
        StdOut.println(board);
    }
  }

  private void solveBoard(Board initial) {
    final MinPQ<SearchNode> mainQ = new MinPQ<>();
    final MinPQ<SearchNode> swappedQ = new MinPQ<>();
    final Board swappedBoard = initial.twin();
    SearchNode mainNode = new SearchNode(initial, null);
    SearchNode swappedNode = new SearchNode(swappedBoard, null);
    boolean foundMainSolution = mainNode.board.isGoal();
    boolean foundSwappedSolution = swappedNode.board.isGoal();

    while (!foundMainSolution && !foundSwappedSolution) {
      for (Board neighbor : mainNode.board.neighbors()) {
        final SearchNode newNode = new SearchNode(neighbor, mainNode);
        if (!newNode.equalsPredecessor(mainNode)) mainQ.insert(newNode);
      }
      for (Board neighbor : swappedNode.board.neighbors()) {
        final SearchNode newNode = new SearchNode(neighbor, mainNode);
        if (!newNode.equalsPredecessor(mainNode)) swappedQ.insert(newNode);
      }
      mainNode = mainQ.delMin();
      swappedNode = swappedQ.delMin();
      foundMainSolution = mainNode.board.isGoal();
      foundSwappedSolution = swappedNode.board.isGoal();
    }
    if (foundMainSolution) {
      while (mainNode != null) {
        winningMoves.push(mainNode.board);
        mainNode = mainNode.predecessor;
      }
    }
  }

  private class SearchNode implements Comparable<SearchNode> {
    private final SearchNode predecessor;
    private final Board board;
    private final int moves;

    private SearchNode(Board board, SearchNode predecessor) {
      this.board = board;
      this.predecessor = predecessor;
      this.moves = predecessor != null ? predecessor.moves + 1 : 0;
    }
    private boolean equalsPredecessor(SearchNode node) {
      return node.predecessor != null && this.board.equals(node.predecessor.board);
    }
    private int priority() {
      return this.board.manhattan() + this.moves;
    }
    public int compareTo(SearchNode node) {
      return Integer.compare(this.priority(), node.priority());
    }
  }
}
